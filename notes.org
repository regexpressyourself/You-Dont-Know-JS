* Scopes & Closures
** Scope
*** Functions
**** Callbacks
     - Always name callback function expressions
       - For debug and readability purposes
**** IIFE - Immediately Invoked Function Expression
     - Call an anonymous function expression right after declaring it
       #+BEGIN_SRC js
     (function(){ .. })()
       #+END_SRC
       or
       #+BEGIN_SRC js
     (function(){ .. }())
       #+END_SRC
       (both work the same)
*** Vars
    - let for block scoping in ES6
    - const for block scoping and constant value in ES6
*** Block Scoping
    - Not allowed most anywhere in JS
**** Allowed in:
     - Catch blocks are block scoped by default
     - let variable - ES6
       - like var, but block scope, not function scope
       - no hoisting
       - Can be used to help in garbage collection (really big vars in small blocks don't hold memory for long)
     - const variable
       - like let, but final
** Hoisting
   - All vars are hoisted
   - functions are hoisted first
     - The last function will be called instead of the first var if both have same name, regardless of placement
     - The last of two functions will be called when they share a name
** Closures
   - Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.
     #+BEGIN_SRC js
     function foo() {
       var a = 2;

       function bar() {
         console.log( a );
         }

       return bar;
     }

     var baz = foo();

     baz(); // 2 -- Whoa, closure was just observed, man.   
     #+END_SRC
     - check it:
       1. foo returns bar to baz, passing it as a value
       2. bar "lives on" in a sense, even beyond its scope, because it is still being referenced by baz
       3. Along with bar the function living on, its scope lives on alongside it. In a sense, it brings the environment it was declared in along with it so it can feel comfy outside of its scope.
       4. Even well after foo has been executed, var a still exists. It is inexorably tied to anything that references bar
     - IIFE can be seen as an example of closure when there is a function inside the function expression
*** Caveats to closure
    #+BEGIN_SRC js
      for (var i=1; i<=5; i++) {
         setTimeout( function timer(){
             console.log( i );
         }, i*1000 );
      }
    #+END_SRC
    6 is printed 5 times. timer() is running 1000 seconds after being called, 6 times over. By the time timer() runs, the for loop will be done, and the i that it was instantiated with will be at 6. each timer() function shares the same scope, and thus the same i.
    
    #+BEGIN_SRC js
      for (var i=1; i<=5; i++) {
          (function(){
              var j = i;
              setTimeout( function timer(){
                  console.log( j );
              }, j*1000 );
          })();
      }
    #+END_SRC
    1 2 3 4 5 is printed, as j is necessarily bound to i in the function, which then is passed to timer(). 
    The IIFE "blocks" the other iterations' timer() function from getting in the way of each other, as it is specific to the iteration 
    
    
    Let and block scoping can fix alllllll this nonsense
    
    #+BEGIN_SRC js

      for (let i=1; i<=5; i++) {
          setTimeout( function timer(){
              console.log( i );
          }, i*1000 );
      }
    #+END_SRC
*** Modules
    - modules make use of closure in a similar way to java and class variables
    - A module is a function that acts like a class, i.e. one that cannot do anything on its own, but can perform actions once instantiated
    #+BEGIN_SRC js :session
      function CoolModule() {
          var something = "cool";
          var another = [1, 2, 3];

          function doSomething() {
              console.log( something );
          }

          function doAnother() {
              console.log( another.join( " ! " ) );
          }
      
          return {
              doSomething: doSomething,
              doAnother: doAnother
          };
      }

      var foo = CoolModule();

      foo.doSomething(); // cool
      foo.doAnother(); // 1 ! 2 ! 3
    #+END_SRC
    
    - ES6 takes it all a step further, making files modules
      - The following imports hello from the file bar.js:
    #+BEGIN_SRC js
      import hello from bar
    #+END_SRC
    
* /this/ & Object Prototypes
** This
*** What this is not
    1. the function itself
       - it does not refer to the function like an object, or store variables tied to the function, or any of the stuff you might think from Java
    2. A cheat for sharing scopes
       - There is absolutely no bridge between scope lookups and this
       - use closures for scope lookups instead!
*** What it is
**** Call-site
     call-site: the location in code where a function was called (not to be confused with where it was declared)
**** Scope
***** Default
     - the this variable refers to the call site, so this.a will be the variable a somewhere in the scope of the function call
       #+BEGIN_SRC js
         function foo() {
             console.log( this.a );
         }

         var a = 2;

         foo(); // 2
       #+END_SRC
       
    - strict mode does not allow this to refer to global scope
      #+BEGIN_SRC js
        function foo() {
            "use strict";
            console.log( this.a );
        }
        var a = 2;
        foo(); // TypeError: `this` is `undefined`

      #+END_SRC
      
***** Implicit
      
      This CAN refer to an object, like in java!! Except it's even cooler. Check this out:
      #+BEGIN_SRC js
        function foo() {
            console.log( this.a );
        }

        var obj = {
            a: 2,
            foo: foo
        };

        obj.foo(); // 2
      #+END_SRC

      And it works like you'd expect:
      #+BEGIN_SRC js
        function foo() {
            console.log( this.a );
        }

        var obj2 = {
            a: 42,
            foo: foo
        };

        var obj1 = {
            a: 2,
            obj2: obj2
        };

        obj1.obj2.foo(); // 42
      #+END_SRC
