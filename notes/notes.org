* Scopes & Closures
** Scope
*** Functions
**** Callbacks
     - Always name callback function expressions
       - For debug and readability purposes
**** IIFE - Immediately Invoked Function Expression
     - Call an anonymous function expression right after declaring it
       #+BEGIN_SRC js
         (function(){ .. })()
       #+END_SRC
       or
       #+BEGIN_SRC js
         (function(){ .. }())
       #+END_SRC
       (both work the same)
*** Vars
    - let for block scoping in ES6
    - const for block scoping and constant value in ES6
*** Block Scoping
    - Not allowed most anywhere in JS
**** Allowed in:
     - Catch blocks are block scoped by default
     - let variable - ES6
       - like var, but block scope, not function scope
       - no hoisting
       - Can be used to help in garbage collection (really big vars in small blocks don't hold memory for long)
     - const variable
       - like let, but final
** Hoisting
   - All vars are hoisted
   - functions are hoisted first
     - The last function will be called instead of the first var if both have same name, regardless of placement
     - The last of two functions will be called when they share a name
** Closures
   - Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.
     #+BEGIN_SRC js
     function foo() {
       var a = 2;

       function bar() {
         console.log( a );
         }

       return bar;
     }

     var baz = foo();

     baz(); // 2 -- Whoa, closure was just observed, man.
     #+END_SRC
     - check it:
       1. foo returns bar to baz, passing it as a value
       2. bar "lives on" in a sense, even beyond its scope, because it is still being referenced by baz
       3. Along with bar the function living on, its scope lives on alongside it. In a sense, it brings the environment it was declared in along with it so it can feel comfy outside of its scope.
       4. Even well after foo has been executed, var a still exists. It is inexorably tied to anything that references bar
     - IIFE can be seen as an example of closure when there is a function inside the function expression
*** Caveats to closure
    #+BEGIN_SRC js
      for (var i=1; i<=5; i++) {
         setTimeout( function timer(){
             console.log( i );
         }, i*1000 );
      }
    #+END_SRC
    6 is printed 5 times. timer() is running 1000 seconds after being called, 6 times over. By the time timer() runs, the for loop will be done, and the i that it was instantiated with will be at 6. each timer() function shares the same scope, and thus the same i.
    
    #+BEGIN_SRC js
      for (var i=1; i<=5; i++) {
          (function(){
              var j = i;
              setTimeout( function timer(){
                  console.log( j );
              }, j*1000 );
          })();
      }
    #+END_SRC
    1 2 3 4 5 is printed, as j is necessarily bound to i in the function, which then is passed to timer().
    The IIFE "blocks" the other iterations' timer() function from getting in the way of each other, as it is specific to the iteration
    
    
    Let and block scoping can fix alllllll this nonsense
    
    #+BEGIN_SRC js

      for (let i=1; i<=5; i++) {
          setTimeout( function timer(){
              console.log( i );
          }, i*1000 );
      }
    #+END_SRC
*** Modules
    - modules make use of closure in a similar way to java and class variables
    - A module is a function that acts like a class, i.e. one that cannot do anything on its own, but can perform actions once instantiated
    #+BEGIN_SRC js :session
      function CoolModule() {
          var something = "cool";
          var another = [1, 2, 3];

          function doSomething() {
              console.log( something );
          }

          function doAnother() {
              console.log( another.join( " ! " ) );
          }

          return {
              doSomething: doSomething,
              doAnother: doAnother
          };
      }

      var foo = CoolModule();

      foo.doSomething(); // cool
      foo.doAnother(); // 1 ! 2 ! 3
    #+END_SRC
    
    - ES6 takes it all a step further, making files modules
      - The following imports hello from the file bar.js:
    #+BEGIN_SRC js
      import hello from bar
    #+END_SRC
    
* /this/ & Object Prototypes
** This
*** What this is not
    1. the function itself
       - it does not refer to the function like an object, or store variables tied to the function, or any of the stuff you might think from Java
    2. A cheat for sharing scopes
       - There is absolutely no bridge between scope lookups and this
       - use closures for scope lookups instead!
*** What it is
**** Call-site
     call-site: the location in code where a function was called (not to be confused with where it was declared)
**** Binding Variations
***** Default
      - the this variable refers to the call site, so this.a will be the variable a somewhere in the scope of the function call
        #+BEGIN_SRC js
          function foo() {
              console.log( this.a );
          }

          var a = 2;

          foo(); // 2
        #+END_SRC
        
      - strict mode does not allow this to refer to global scope
        #+BEGIN_SRC js
          function foo() {
              "use strict";
              console.log( this.a );
          }
          var a = 2;
          foo(); // TypeError: `this` is `undefined`

        #+END_SRC
        
***** Implicit
      
      This CAN refer to an object, like in java!! Except it's even cooler. Check this out:
      #+BEGIN_SRC js
        function foo() {
            console.log( this.a );
        }

        var obj = {
            a: 2,
            foo: foo
        };

        obj.foo(); // 2
      #+END_SRC
      
      And it works like you'd expect:
      #+BEGIN_SRC js
        function foo() {
            console.log( this.a );
        }

        var obj2 = {
            a: 42,
            foo: foo
        };

        var obj1 = {
            a: 2,
            obj2: obj2
        };

        obj1.obj2.foo(); // 42
      #+END_SRC
      
***** Explicit
      - binding the function in the object declaration can get a little messy
      - To be certain that "this" refers to a specific option, you can explicitly bind the function and the object using the call or apply methods
      - foo.call(obj) will make certain that "this" in foo refers to obj.
****** Hard binding
       - explicit binding can still act funny sometimes. Hard binding is the end-all answer
       - hard binding uses a second function to bind foo to obj (in our example)
       #+BEGIN_SRC js
         function foo(something) {
             console.log( this.a, something );
             return this.a + something;
         }

         // simple `bind` helper
         function bind(fn, obj) {
             return function() {
                 return fn.apply( obj, arguments );
             };
         }

         var obj = {
             a: 2
         };

         var bar = bind( foo, obj );

         var b = bar( 3 ); // 2 3
         console.log( b ); // 5
       #+END_SRC
       - This bind function is included in ES5 and doesn't need to be rewritten
         #+BEGIN_SRC js
                function foo(something) {
                    console.log( this.a, something );
                    return this.a + something;
                }

                var obj = {
                    a: 2
                };

                var bar = foo.bind( obj ); // Boom

                var b = bar( 3 ); // 2 3
                console.log( b ); // 5
         #+END_SRC
         
       - in ES6, the hard-bound function has a .name attribute for debugging purposes
         
***** "new" Binding
      - there are no real constructors in js
      - constructors are simply a function preceded by "new"
      - "new <function>" makes <function> into a constructor, runs it, and returns a prototype object
      - The new object is now the this for that function
        #+BEGIN_SRC js
           function foo(a) {
               this.a = a;
           }

           var bar = new foo( 2 );
           console.log( bar.a ); // 2
        #+END_SRC
***** Precedence
      1. new
      2. explicit/hard
      3. implicit
      4. default
****** From the book:
       
       1. Is the function called with new (new binding)? If so, this is the newly constructed object.
          
          #+BEGIN_SRC js
              var bar = new foo()
          #+END_SRC
          
       2. Is the function called with call or apply (explicit binding), even hidden inside a bind hard binding? If so, this is the explicitly specified object.
          
          #+BEGIN_SRC js
            var bar = foo.call( obj2 )
          #+END_SRC
          
       3. Is the function called with a context (implicit binding), otherwise known as an owning or containing object? If so, this is that context object.
          
          #+BEGIN_SRC js
            var bar = obj1.foo()
          #+END_SRC
          
       4. Otherwise, default the this (default binding). If in strict mode, pick undefined, otherwise pick the global object.
          
          #+BEGIN_SRC js
            var bar = foo()
          #+END_SRC
***** ES6 Caveat - Arrow function
      - An arrow function allows functions to inherit "this" from up a lexical layer, whether that be another function or global scope
      - uses => instead of "function"
        #+BEGIN_SRC js
            function foo() {
                setTimeout(() => {
                    // `this` here is lexically adopted from `foo()`
                    console.log( this.a );
                },100);
            }

            var obj = {
                a: 2
            };

            foo.call( obj ); // 2
        #+END_SRC
** Objects
*** 6 types:
    1. string
    2. number
    3. boolean 
    4. null
    5. undefined
    6. object
*** Built in Objects:

    1. String 
    2. Number
    3. Boolean
    4. Object
    5. Function
    6. Array
    7. Date
    8. RegExp
    9. Error

       primary types like string will be automatically cast to String when String functions are called on them
*** Properties
    - property names are always strings
    - There is no method property, as methods are necessarily tied to their objects. While an object in js can use a function, it cannot tie the function to itself.
    - Arrays are like objects, but they have numerical properties
      - they can have non-numerical properties, but it can get messy
**** Copying Objects and Properties
     - Shallow copy: copy one object deep (keep references of other objects contained in the copied objects)
     - Deep copy: copy all the way down, creating new references to new objects until you get to only primary types
***** Solutions:
      1. To JSON and Back:
      #+BEGIN_SRC js
        var newObj = JSON.parse( JSON.stringify( someObj ) );
      #+END_SRC
      1. ES6:
         #+BEGIN_SRC js
           /* <target> = Object.assign(<target>,<source>); */
           var newObj = Object.assign( {}, myObject );
         #+END_SRC
         - Creates a shallow copy, keeping any object references from the copied object the same
**** Property Descriptors

     #+BEGIN_SRC js
           var myObject = {
               a: 2
           };

           Object.getOwnPropertyDescriptor( myObject, "a" );
           // {
           //    value: 2,
           //    writable: true,
           //    configurable: true
           //    enumerable: true,
           // }
     #+END_SRC
***** value
      The value of the property. Can be set with either:
      1. dot syntax
         #+BEGIN_SRC js
           myobj.a = 2;
         #+END_SRC
      2. bracket syntax
         #+BEGIN_SRC js
           myobj["a"] = 2;
         #+END_SRC
***** writable
      The ability to change the value after it is set. Reassignments fail silently when not in strict mode.

***** configurable
      The ability to change the property descriptor. Cannot be undone once set (as you can't change the descriptor...).
***** enumerable
      Whether or not the property comes up in "for .. in" loops.

*** Immutability

**** Object Constant
     By combining writable:false and configurable:false, you can essentially create a constant (cannot be changed, redefined or deleted) as an object property.

**** Prevent Extensions
     If you want to prevent an object from having new properties added to it, but otherwise leave the rest of the object's properties alone, call Object.preventExtensions(..)

**** Seal
     Object.seal(..) creates a "sealed" object, which means it takes an existing object and essentially calls Object.preventExtensions(..) on it, but also marks all its existing properties as configurable:false.

**** Freeze
     Object.freeze(..) creates a frozen object, which means it takes an existing object and essentially calls Object.seal(..) on it, but it also marks all "data accessor" properties as writable:false, so that their values cannot be changed.

**** Deep Freeze 
     call Object.freeze(..) on the object, and then recursively iterating over all objects it references (which would have been unaffected thus far), and calling Object.freeze(..) on them as well.
*** Getters and Setters
    #+BEGIN_SRC js
      var myObject = {
          // define a getter for `a`
          get a() {
              return this._a_;
          },

          // define a setter for `a`
          set a(val) {
              this._a_ = val * 2;
          }
      };

      myObject.a = 2;

      myObject.a; // 4
    #+END_SRC

*** Mixins
    Since objects are not classes and do not employ polymorphism or inheritance, mixins are the hacky solution.

**** Explicit Mixins

     #+BEGIN_SRC js
       // vastly simplified `mixin(..)` example:
       function mixin( sourceObj, targetObj ) {
           for (var key in sourceObj) {
               // only copy if not already present
               if (!(key in targetObj)) {
                   targetObj[key] = sourceObj[key];
               }
           }

           return targetObj;
       }

       var Vehicle = {
           engines: 1,

           ignition: function() {
               console.log( "Turning on my engine." );
           },

           drive: function() {
               this.ignition();
               console.log( "Steering and moving forward!" );
           }
       };

       var Car = mixin( Vehicle, {
           wheels: 4,

           drive: function() {
               Vehicle.drive.call( this ); // make sure that "this" is Car, not Vehicle
               console.log( "Rolling on all " + this.wheels + " wheels!" );
           }
       } );
     #+END_SRC

**** Implicit Mixins

     #+BEGIN_SRC js
       var Something = {
           cool: function() {
               this.greeting = "Hello World";
               this.count = this.count ? this.count + 1 : 1;
           }
       };

       Something.cool();
       Something.greeting; // "Hello World"
       Something.count; // 1

       var Another = {
           cool: function() {
               // implicit mixin of `Something` to `Another`
               Something.cool.call( this );
           }
       };

       Another.cool();
       Another.greeting; // "Hello World"
       Another.count; // 1 (not shared state with `Something`)

     #+END_SRC
**** Basically, just don't even bother with forcing OO concepts into js objects. If you want to write OO, use java or ES6, but this is just gross.

** Prototypes

*** Prototype Chain
    - Basically, how js looks up properties in objects. 
    - Similar to Inheritance, if a property isn't declared in one object, the interpreter will look "up" the chain to see if it's declared elsewhere. 
*** Object.prototype
    - The super-prototype to all prototypes (the Object of javascript)
*** Setting and Shadowing
    - Setting a property may cause shadowing if the same property exists in an object higher up the prototype chain
      - consider this:
        1. myObject is down the prototype chain from youObject
        2. yourObject contains a property 'foo'
        3. I set a 'foo' property on myObject by "myObject.foo = 2;"
        4. myObject's 'foo' /shadows/ youObject's 'foo'
    - Shadowing doesn't always occur like you think.
      - If you want to be sure to shadow, use Object.defineProperty(..) to add properties.


    if myObject set the property foo, and is down the prototype chain from yourObject( which already had a foo property) myObject
*** "Classes" and Prototypal Inheritance
    So mixins aren't classes and objects aren't classes but there's still constructors which implies there's classes so what's up? Enter "Prototypal Inheritance"
**** Reminder of OO Inheritance
     - In object oriented languages, inheritance implies a parent class making copies of itself to it's children. The children then add methods and more specific functionality.
       - This is reinforced by the terms "parent" and "child."
     - This method is very "downward" with the parents looking down over the children
**** Prototypal Inheritance (which is actually not really inheritance at all)
     - Prototypal inheritance is when objects are linked upward to a common parent prototype object, attained from some constructor function. The flow is much more Object -> Parent than Parent -> Object
***** Constructors 
      - subset of the function object- a constructor function
      - Usually start with capital letter since they represent an object
      - Any function can be a constructor
        - It just has to have the "new" keyword in front of it (new Foo())
      - Constructors always return an object, but they also do whatever else is in the function.
***** Inheritance
      - all functions by default get a public, non-enumerable property on them called prototype which points at an otherwise arbitrary object.
        - This is not to be confused with the object prototypes discussed earlier, and is a different object
        - The prototype object is immediately above the object on the prototype chain
          - Any functions or variables on a constructor function's prototype will be fallen back on when called on the constructed object
            #+BEGIN_SRC js
              function Foo() {
                  // ...
              }

              var a = new Foo();

              Object.getPrototypeOf( a ) === Foo.prototype; // true for all new Foo()s
            #+END_SRC
      - Prototypal Inheritance allows a single constructor function to construct multiple instances of the same object. 
        - The multiple objects are linked together by a "parent" <Object>.prototype object.
          #+BEGIN_SRC js
              function Foo(name) {
                  this.name = name;
              }

              Foo.prototype.myName = function() {
                  return this.name;
              };

              var a = new Foo( "a" );
              var b = new Foo( "b" );

              a.myName(); // "a"
              b.myName(); // "b"
          #+END_SRC
      - 
      - 
      - 
      - 
      - 
      - 

***** In Action (just some cool code)
      #+BEGIN_SRC js
        function Foo(name) {
            this.name = name;
        }

        Foo.prototype.myName = function() {
            return this.name;
        };

        function Bar(name,label) {
            Foo.call( this, name );
            this.label = label;
        }

        // here, we make a new `Bar.prototype`
        // linked to `Foo.prototype`
        // Note: Bar.prototype is gone completely
        Bar.prototype = Object.create( Foo.prototype );

        // Beware! Now `Bar.prototype.constructor` is gone,
        // and might need to be manually "fixed" if you're
        // in the habit of relying on such properties!

        Bar.prototype.myLabel = function() {
            return this.label;
        };

        var a = new Bar( "a", "obj a" );

        a.myName(); // "a"
        a.myLabel(); // "obj a"

      #+END_SRC

***** Up the Chain We Go
      - instanceof:

      #+BEGIN_SRC js
        function Foo() {
            // ...
        }
        var a = new Foo();
      #+END_SRC

****** instanceof
       The instanceof operator takes a plain object as its left-hand operand and a function as its right-hand operand. The question instanceof answers is: in the entire Prototype chain of a, does the object arbitrarily pointed to by Foo.prototype ever appear?
       #+BEGIN_SRC js
        a instanceof Foo; // true
       #+END_SRC

****** isPrototypeOf
       The question isPrototypeOf(..) answers is: in the entire Prototype chain of a, does Foo.prototype ever appear?
       #+BEGIN_SRC js
        Foo.prototype.isPrototypeOf( a ); // true
       #+END_SRC
****** getPrototypeOf
       directly retrieve the Prototype of an object. 
       #+BEGIN_SRC js
        Object.getPrototypeOf( a ); // Foo.prototype
       #+END_SRC
***** Frustrated? Scared? Never fear! 
      Instead of dealing with the whole mess of .prototypes and .constructors getting all messed up by calling our constructor and adding its .prototype object to our prototype chain on our object, let's just do something else. 
      #+BEGIN_SRC js
        var foo = {
            something: function() {
                console.log( "Tell me something good..." );
            }
        };

        var bar = Object.create( foo );

        bar.something(); // Tell me something good...
      #+END_SRC
      Object.create(..) creates a new object (bar) linked to the object we specified (foo), which gives us all the power (delegation) of the Prototype mechanism, but without any of the unnecessary complication of new functions acting as classes and constructor calls, confusing .prototype and .constructor references, or any of that extra stuff.
** Behavior Delegation - the alternative view on prototypes
   Behavior Delegation means: let some object (XYZ) provide a delegation (to Task) for property or method references if not found on the object (XYZ).

   - So, in typical OO inheritance, subclasses inherit all the stuff from their parents and add to/change/specify it. 
   - In js "inheritance," objects share links to other objects, but do not contain their own versions of methods/properties found "up the chain."
   - When an object is given a property it doesn't have, the interpreter works up the prototype chain. If the property is found, it is called on THAT object, not on the original object.
     #+BEGIN_SRC js
          var Task = {
              setID: function(ID) { this.id = ID; },
              outputID: function() { console.log( this.id ); }
          };

          // make `XYZ` delegate to `Task`
          var XYZ = Object.create( Task );

          XYZ.prepareTask = function(ID,Label) {
              this.setID( ID );
              this.label = Label;
          };

          XYZ.outputTaskDetails = function() {
              this.outputID();
              console.log( this.label );
          };
     #+END_SRC
     - Note: Avoid overriding methods or variables in this style
       - instead, use general functions to compose more specific functions in the child

*** Objects Linked To Other Objects (OLOO)
    - An alternative to OO
    - another word for behavior delegation
    - The "right" way of polymorphism in js
*** Example: Class vs Behavior Delegation 
**** Class:
     #+BEGIN_SRC js
         // Parent class
         function Controller() {
             this.errors = [];
         }
         Controller.prototype.showDialog = function(title,msg) {
             // display title & message to user in dialog
         };
         Controller.prototype.success = function(msg) {
             this.showDialog( "Success", msg );
         };
         Controller.prototype.failure = function(err) {
             this.errors.push( err );
             this.showDialog( "Error", err );
         };

         // Child class
         function LoginController() {
             Controller.call( this );
         }
         // Link child class to parent
         LoginController.prototype = Object.create( Controller.prototype );
         LoginController.prototype.getUser = function() {
             return document.getElementById( "login_username" ).value;
         };
         LoginController.prototype.getPassword = function() {
             return document.getElementById( "login_password" ).value;
         };
         LoginController.prototype.validateEntry = function(user,pw) {
             user = user || this.getUser();
             pw = pw || this.getPassword();

             if (!(user && pw)) {
                 return this.failure( "Please enter a username & password!" );
             }
             else if (pw.length < 5) {
                 return this.failure( "Password must be 5+ characters!" );
             }

             // got here? validated!
             return true;
         };
         // Override to extend base `failure()`
         LoginController.prototype.failure = function(err) {
             // "super" call
             Controller.prototype.failure.call( this, "Login invalid: " + err );
         };

         // Child class
         function AuthController(login) {
             Controller.call( this );
             // in addition to inheritance, we also need composition
             this.login = login;
         }
         // Link child class to parent
         AuthController.prototype = Object.create( Controller.prototype );
         AuthController.prototype.server = function(url,data) {
             return $.ajax( {
                 url: url,
                 data: data
             } );
         };
         AuthController.prototype.checkAuth = function() {
             var user = this.login.getUser();
             var pw = this.login.getPassword();

             if (this.login.validateEntry( user, pw )) {
                 this.server( "/check-auth",{
                     user: user,
                     pw: pw
                 } )
                 .then( this.success.bind( this ) )
                 .fail( this.failure.bind( this ) );
             }
         };
         // Override to extend base `success()`
         AuthController.prototype.success = function() {
             // "super" call
             Controller.prototype.success.call( this, "Authenticated!" );
         };
         // Override to extend base `failure()`
         AuthController.prototype.failure = function(err) {
             // "super" call
             Controller.prototype.failure.call( this, "Auth Failed: " + err );
         };

         var auth = new AuthController(
             // in addition to inheritance, we also need composition
             new LoginController()
         );

         auth.checkAuth();
     #+END_SRC
**** Behavior Delegation:
     #+BEGIN_SRC js
         var LoginController = {
             errors: [],
             getUser: function() {
                 return document.getElementById( "login_username" ).value;
             },
             getPassword: function() {
                 return document.getElementById( "login_password" ).value;
             },
             validateEntry: function(user,pw) {
                 user = user || this.getUser();
                 pw = pw || this.getPassword();

                 if (!(user && pw)) {
                     return this.failure( "Please enter a username & password!" );
                 }
                 else if (pw.length < 5) {
                     return this.failure( "Password must be 5+ characters!" );
                 }

                 // got here? validated!
                 return true;
             },
             showDialog: function(title,msg) {
                 // display success message to user in dialog
             },
             failure: function(err) {
                 this.errors.push( err );
                 this.showDialog( "Error", "Login invalid: " + err );
             }
         };

         // Link `AuthController` to delegate to `LoginController`
         var AuthController = Object.create( LoginController );

         AuthController.errors = [];
         AuthController.checkAuth = function() {
             var user = this.getUser();
             var pw = this.getPassword();

             if (this.validateEntry( user, pw )) {
                 this.server( "/check-auth",{
                     user: user,
                     pw: pw
                 } )
                 .then( this.accepted.bind( this ) )
                 .fail( this.rejected.bind( this ) );
             }
         };
         AuthController.server = function(url,data) {
             return $.ajax( {
                 url: url,
                 data: data
             } );
         };
         AuthController.accepted = function() {
             this.showDialog( "Success", "Authenticated!" )
         };
         AuthController.rejected = function(err) {
             this.failure( "Auth Failed: " + err );
         };

     #+END_SRC

** ES6 Classes
   Really just the same old hacky solution, with a little syntactic help. Kindof a middle zone between class and behavioral.

*** Comparison:
**** ES5
     #+BEGIN_SRC js
       // Parent class
       function Widget(width,height) {
           this.width = width || 50;
           this.height = height || 50;
           this.$elem = null;
       }

       Widget.prototype.render = function($where){
           if (this.$elem) {
               this.$elem.css( {
                   width: this.width + "px",
                   height: this.height + "px"
               } ).appendTo( $where );
           }
       };

       // Child class
       function Button(width,height,label) {
           // "super" constructor call
           Widget.call( this, width, height );
           this.label = label || "Default";

           this.$elem = $( "<button>" ).text( this.label );
       }

       // make `Button` "inherit" from `Widget`
       Button.prototype = Object.create( Widget.prototype );

       // override base "inherited" `render(..)`
       Button.prototype.render = function($where) {
           // "super" call
           Widget.prototype.render.call( this, $where );
           this.$elem.click( this.onClick.bind( this ) );
       };

       Button.prototype.onClick = function(evt) {
           console.log( "Button '" + this.label + "' clicked!" );
       };

       $( document ).ready( function(){
           var $body = $( document.body );
           var btn1 = new Button( 125, 30, "Hello" );
           var btn2 = new Button( 150, 40, "World" );

           btn1.render( $body );
           btn2.render( $body );
       } );
     #+END_SRC

**** ES6
     #+BEGIN_SRC js
       class Widget {
           constructor(width,height) {
               this.width = width || 50;
               this.height = height || 50;
               this.$elem = null;
           }
           render($where){
               if (this.$elem) {
                   this.$elem.css( {
                       width: this.width + "px",
                       height: this.height + "px"
                   } ).appendTo( $where );
               }
           }
       }

       class Button extends Widget {
           constructor(width,height,label) {
               super( width, height );
               this.label = label || "Default";
               this.$elem = $( "<button>" ).text( this.label );
           }
           render($where) {
               super.render( $where );
               this.$elem.click( this.onClick.bind( this ) );
           }
           onClick(evt) {
               console.log( "Button '" + this.label + "' clicked!" );
           }
       }

       $( document ).ready( function(){
           var $body = $( document.body );
           var btn1 = new Button( 125, 30, "Hello" );
           var btn2 = new Button( 150, 40, "World" );

           btn1.render( $body );
           btn2.render( $body );
       } );
     #+END_SRC
*** OOPO/Behavioral Delegation way of doing it
    #+BEGIN_SRC js
      var Widget = {
          init: function(width,height){
              this.width = width || 50;
              this.height = height || 50;
              this.$elem = null;
          },
          insert: function($where){
              if (this.$elem) {
                  this.$elem.css( {
                      width: this.width + "px",
                      height: this.height + "px"
                  } ).appendTo( $where );
              }
          }
      };

      var Button = Object.create( Widget );

      Button.setup = function(width,height,label){
          // delegated call
          this.init( width, height );
          this.label = label || "Default";

          this.$elem = $( "<button>" ).text( this.label );
      };
      Button.build = function($where) {
          // delegated call
          this.insert( $where );
          this.$elem.click( this.onClick.bind( this ) );
      };
      Button.onClick = function(evt) {
          console.log( "Button '" + this.label + "' clicked!" );
      };

      $( document ).ready( function(){
          var $body = $( document.body );

          var btn1 = Object.create( Button );
          btn1.setup( 125, 30, "Hello" );

          var btn2 = Object.create( Button );
          btn2.setup( 150, 40, "World" );

          btn1.build( $body );
          btn2.build( $body );
      } );
    #+END_SRC
*** Same issues as the ES5 way of doing it:
    #+BEGIN_SRC js
         class C {
             constructor() {
                 this.num = Math.random();
             }
             rand() {
                 console.log( "Random: " + this.num );
             }
         }

         var c1 = new C();
         c1.rand(); // "Random: 0.4324299..."

         C.prototype.rand = function() {
             console.log( "Random: " + Math.round( this.num * 1000 ));
         };

         var c2 = new C();
         c2.rand(); // "Random: 867"

         c1.rand(); // "Random: 432" -- oops!!!
    #+END_SRC

* Types & Grammar
** 7 types:
   1. string
   2. number
   3. boolean 
   4. null
   5. undefined
   6. object
   7. symbol (new to ES6)
*** Notes on the types:
    - Values have a type, variables do not
    - values are initialized to undefined until set otherwise
** By Value or By Reference
   - Simple scalar primitives (strings, numbers, etc.) are assigned/passed by value-copy,
   - compound values (objects, etc.) are assigned/passed by reference-copy.
   - A reference in JS points at a (shared) value, so if you have 10 different references, they are all always distinct references to a single shared value; none of them are references/pointers to each other.
     - References are not like references/pointers in other languages -- they're never pointed at other variables/references, only at the underlying values.
** Native Objects

   Native objects are object wrappers around primitives that include some functions and values to use

   1. String()
   2. Number()
   3. Boolean()
   4. Array()
   5. Object()
   6. Function()
   7. RegExp()
   8. Date()
   9. Error()
   10. Symbol() -- added in ES6!
*** Boxing your own objects
    - might make sense to do this, but look at what happend:

    #+BEGIN_SRC js
      var a = new Boolean( false );
      if (!a) {
        console.log( "Oops" ); // never runs
      }
    #+END_SRC

    - The right way:
    #+BEGIN_SRC js
      var a = "abc";
      var b = new String( a );
      var c = Object( a );

      typeof a; // "string"
      typeof b; // "object"
      typeof c; // "object"

      b instanceof String; // true
      c instanceof String; // true

      Object.prototype.toString.call( b ); // "[object String]"
      Object.prototype.toString.call( c ); // "[object String]"
    #+END_SRC
*** Unboxing
    #+BEGIN_SRC js
      var a = new String( "abc" );
      var b = new Number( 42 );
      var c = new Boolean( true );

      a.valueOf(); // "abc"
      b.valueOf(); // 42
      c.valueOf(); // true
    #+END_SRC

* Async and Performance
** Asynchrony
*** Event Loop
    The event loop is the manner in which javascript's engine processes chunks of code. Code is passed into the engine in a queue, and the queue is looped over, calling events when they reach the front of the queue.
    - callbacks are simply removed from the queue until their caller finishes. They are then added back into the queue.
    - setTimeout() doesn't work like a callback , and only adds your function to the queue after a timer, but doesn't guarantee it will be at the front of the queue.
*** Races
    Race conditions can occur in js when two functions manipulating the same variables are called as callbacks to some other async functions.
**** Fixes
     - before:
       #+BEGIN_SRC js
         var res = [];

         function response(data) {
             res.push( data );
         }

         // ajax(..) is some arbitrary Ajax function given by a library
         ajax( "http://some.url.1", response );
         ajax( "http://some.url.2", response );
       #+END_SRC

     - after:
       #+BEGIN_SRC js

         var res = [];

         function response(data) {
             if (data.url == "http://some.url.1") {
                 res[0] = data;
             }
             else if (data.url == "http://some.url.2") {
                 res[1] = data;
             }
         }

         // ajax(..) is some arbitrary Ajax function given by a library
         ajax( "http://some.url.1", response );
         ajax( "http://some.url.2", response );
       #+END_SRC
** Callbacks
   A callback is a function that is tied to the completion of another function. This creates a kind of asyncrony, as the program continues executing after the parent function starts, then execution is interrupted the callback function is "called back" after it is done.
*** Inversion of Control
    The ad-hoc async of callbacks make for some weird behavior. If the parent function does not call the callback appropriately, you can end up with a problem. 

    This is called "inversion of control." So-called because the control is taken from the child function (what we're writing in our program) and giving it to the parent function (which may be some kind of external API call that we have no control over). As a result, we have no power over how the callback is called, which can lead to:
*** Problems
    1. Call the callback too early (before it's been tracked)
    2. Call the callback too late (or never)
    3. Call the callback too few or too many times (like the problem you encountered!)
    4. Fail to pass along any necessary environment/parameters to your callback
    5. Swallow any errors/exceptions that may happen
*** Solutions
    Promises address these problems, so just use that. Otherwise, you can:
    1. Double callback (Promises use something like this)
       - Two callbacks are provided, one function for success, another for error
    2. Double parameter callback ("Node Style")
       - The callback function is given two parameters, error and data.
       - The callback can check for error==true up front, and then go on handling data if no error
    3. Some other thing - come back here
** Promises
*** Inverting Inversion of Control
    Promises uninvert the inversion of control caused by callbacks. They give the power back to the waiting function, and allow the parent function to be used as part of a whole, rather than dictating the entire process.
*** "Events"
    You can think of promises as events and event listeners in a way. The parent process creates and event that the children wait for before executing. When a promise returns, it will "resolve" or "reject" the returned value ("resolve(2)")
    #+BEGIN_SRC js
     function foo(x) {
         // start doing something that could take a while

         // make a `listener` event notification
         // capability to return

         return listener;
     }

     var evt = foo( 42 );

     evt.on( "completion", function(){
         // now we can do the next step!
     } );

     evt.on( "failure", function(err){
         // oops, something went wrong in `foo(..)`
     } );
    #+END_SRC

    The events are not really events, but the principle is the same.
    #+BEGIN_SRC js
      function bar(fooPromise) {
          // listen for `foo(..)` to complete
          fooPromise.then(
              function(){
                  // `foo(..)` has now finished, so
                  // do `bar(..)`'s task
              },
              function(){
                  // oops, something went wrong in `foo(..)`
              }
          );
      }

      // ditto for `baz(..)`


      function foo(x) {
          // start doing something that could take a while

          // construct and return a promise
          return new Promise( function(resolve,reject){
              // eventually, call `resolve(..)` or `reject(..)`,
              // which are the resolution callbacks for
              // the promise.
          } );
      }

      var p = foo( 42 );

      bar( p );

      baz( p );

    #+END_SRC
    or
    #+BEGIN_SRC js
      function bar() {
          // `foo(..)` has definitely finished, so
          // do `bar(..)`'s task
      }

      function oopsBar() {
          // oops, something went wrong in `foo(..)`,
          // so `bar(..)` didn't run
      }

      // ditto for `baz()` and `oopsBaz()`


      function foo(x) {
          // start doing something that could take a while

          // construct and return a promise
          return new Promise( function(resolve,reject){
              // eventually, call `resolve(..)` or `reject(..)`,
              // which are the resolution callbacks for
              // the promise.
          } );
      }

      var p = foo( 42 );

      p.then( bar, oopsBar );

      p.then( baz, oopsBaz );
      #+END_SRC
    Promises are immutable, and "then" can be called on them wherever. In the first example, "then" is called inside bar and baz. In the second, it is called in the global scope, on p itself. Both work identically, and both are correct. The proper use will be situational.
*** Callback Problems Revisited
    The inversion of control in callbacks causes problems of trusting an api call to work properly, and avoid: 

    1. Call the callback too early (before it's been tracked)
    2. Call the callback too late (or never)
    3. Call the callback too few or too many times (like the problem you encountered!)
    4. Fail to pass along any necessary environment/parameters to your callback
    5. Swallow any errors/exceptions that may happen

    These problems are addressed by promises:
**** Call too early
     "then" acts as a barrier to forcing synchronous calls, ensuring that all calls are async and do not run until the promise resolves
**** Call too late
     It's not possible for synchronous observation, so it's not possible for a synchronous chain of tasks to run in such a way to in effect "delay" another callback from happening as expected.
**** Never call
     You can specify a max time for a promise to return with "Promise.race"
    #+BEGIN_SRC js
      // a utility for timing out a Promise
      function timeoutPromise(delay) {
          return new Promise( function(resolve,reject){
              setTimeout( function(){
                  reject( "Timeout!" );
              }, delay );
          } );
      }

      // setup a timeout for `foo()`
      Promise.race( [
          foo(),                  // attempt `foo()`
          timeoutPromise( 3000 )  // give it 3 seconds
      ] )
      .then(
          function(){
              // `foo(..)` fulfilled in time!
          },
          function(err){
              // either `foo()` rejected, or it just
              // didn't finish in time, so inspect
              // `err` to know which
          }
      );
    #+END_SRC
**** Call too much or too little
     Promises always resolve exactly 1 time with either resolve or reject. Too few is covered above under "Never call." 
     The "too many" case is easy to explain. If for some reason the Promise creation code tries to call resolve(..) or reject(..) multiple times, or tries to call both, the Promise will accept only the first resolution, and will silently ignore any subsequent attempts.
**** Fail to pass parameters/environment
Promises can have, at most, one resolution value (fulfillment or rejection).

Something to be aware of: If you call resolve(..) or reject(..) with multiple parameters, all subsequent parameters beyond the first will be silently ignored
**** Swallowing errors
     Errors are always passed down the promise chain.

    #+BEGIN_SRC js
      var p = new Promise( function(resolve,reject){
          foo.bar();  // `foo` is not defined, so error!
          resolve( 42 );  // never gets here :(
      } );

      p.then(
          function fulfilled(){
              // never gets here :(
          },
          function rejected(err){
              // `err` will be a `TypeError` exception object
              // from the `foo.bar()` line.
          }
      );
          #+END_SRC

    Here, the promise created by p.then() is not caught, so the error is not caught.
    #+BEGIN_SRC js
      var p = new Promise( function(resolve,reject){
          resolve( 42 );
      } );

      p.then(
          function fulfilled(msg){
              foo.bar();
              console.log( msg ); // never gets here :(
          },
          function rejected(err){
              // never gets here either :(
          }
      );
    #+END_SRC
**** Lingering Trust Problems
     Since the definition of promises is a loose, duck-typed search for a "then"able, you can get some strange responses when the "then" property is directly changed.
     #+BEGIN_SRC js
      var p = {
          then: function(cb,errcb) {
              cb( 42 );
              errcb( "evil laugh" );
          }
      };

      p
      .then(
          function fulfilled(val){
              console.log( val ); // 42
          },
          function rejected(err){
              // oops, shouldn't have run
              console.log( err ); // evil laugh
          }
      );
     #+END_SRC
     Promise.resolve() will fix this, running through the "thens" until a genuine promise is found.
     #+BEGIN_SRC js
      // don't just do this:
      foo( 42 )
      .then( function(v){
          console.log( v );
      } );

      // instead, do this:
      Promise.resolve( foo( 42 ) )
      .then( function(v){
          console.log( v );
      } );
     #+END_SRC
     It kindof works as a ditch-effort wrapper to make sure the promise is a trustable, proper promise
*** Promise Chain
    Calling "then" on a promise actually returns a new promise itself. We can run down this sequence to chain events together. This can work in much the same way as chaining functions, with the return of one acting as the input for another.
     #+BEGIN_SRC js
       var p = Promise.resolve( 21 );

       var p2 = p.then( function(v){
           console.log( v );   // 21

           // fulfill `p2` with value `42`
           return v * 2;
       } );

       // chain off `p2`
       p2.then( function(v){
           console.log( v );   // 42
       } );
       #+END_SRC
     The p2 temp value is not strictly necessary
     #+BEGIN_SRC js
       var p = Promise.resolve( 21 );

       p
       .then( function(v){
           console.log( v );   // 21

           // fulfill the chained promise with value `42`
           return v * 2;
       } )
       // here's the chained promise
       .then( function(v){
           console.log( v );   // 42
       } );
     #+END_SRC
To make sure the chained process happen asynchronously and in order of calling, make sure to explicitly return a promise in parts of the chain that need async support.
     #+BEGIN_SRC js
       var p = Promise.resolve( 21 );

       p.then( function(v){
           console.log( v );   // 21

           // create a promise to return
           return new Promise( function(resolve,reject){
               // introduce asynchrony!
               setTimeout( function(){
                   // fulfill with value `42`
                   resolve( v * 2 );
               }, 100 );
           } );
       } )
       .then( function(v){
           // runs after the 100ms delay in the previous step
           console.log( v );   // 42
       } );
     #+END_SRC
or with an AJAX example
     #+BEGIN_SRC js
       // assume an `ajax( {url}, {callback} )` utility

       // Promise-aware ajax
       function request(url) {
           return new Promise( function(resolve,reject){
               // the `ajax(..)` callback should be our
               // promise's `resolve(..)` function
               ajax( url, resolve );
           } );
       }
       request( "http://some.url.1/" )
       .then( function(response1){
           return request( "http://some.url.2/?v=" + response1 );
       } )
       .then( function(response2){
           console.log( response2 );
       } );
     #+END_SRC
*** Terms: fulfill, resolve, and reject
    Generally think of the three terms as: reject for failure, fulfill for success, and resolve for resolution through either rejection or fulfillment.

    Parameters of a Promise can have any name, but are set up with the first as fulfilling the promise and the second for rejecting the promise. 

    #+BEGIN_SRC js
       var p = new Promise( function(X,Y){
           // X() for fulfillment
           // Y() for rejection
       } );
    #+END_SRC
**** Reject
     Easy. The second parameter of a promise. Any error in the promise will trigger reject. The second parameter should always be called "reject".
**** Resolve
     As in Promise.resolve(), resolve simply takes a promise and resolves it to trigger fulfillment or rejection.

     #+BEGIN_SRC js
       var rejectedTh = {
           then: function(resolved,rejected) {
               rejected( "Oops" );
           }
       };

       var rejectedPr = Promise.resolve( rejectedTh );
     #+END_SRC
     In this sense, the promise itself should be given a first parameter labeled "resolve."
**** Fulfill
     After a promise has been returned, it will be either fulfilled or rejected.
     #+BEGIN_SRC js
       var rejectedPr = new Promise( function(resolve,reject){
           // resolve this promise with a rejected promise
           resolve( Promise.reject( "Oops" ) );
       } );

       rejectedPr.then(
           function fulfilled(){
               // never gets here
           },
           function rejected(err){
               console.log( err ); // "Oops"
           }
       );
     #+END_SRC
     As a result, the functions supplied to "then" should be labeled fulfill and reject.

     Note: the ES6 specification uses onFulfilled(..) and onRejected(..) to label these two callbacks
*** Errors
    - Can't use try-catch, as it only works for synchronous code.
    - Errors in the "then" block won't be caught with the reject function, as they are errors on the promise created by "then." They will be passed along the promise chain, which may jvery well not exist.
**** Solution 1: catch away

     One solution is to always include a catch block under your last "then"
     #+BEGIN_SRC js
       var p = Promise.resolve( 42 );

       p.then(
           function fulfilled(msg){
               // numbers don't have string functions,
               // so will throw an error
               console.log( msg.toLowerCase() );
           }
       )
           .catch( handleErrors );
     #+END_SRC
     The problem here is that any errors in handleErrors will not be caught. You would need another catch block underneath, and another, and another....

     However, as long as you make the final catch a super simple block, you should be good
**** Solution 2: add to ES6
     This is weird and complex and scary and I don't think I'll need it any time soon
*** Alternative flow to the promise chain
**** Promise.all([])
     Pass an array of promises to wait on
     #+BEGIN_SRC js
       // `request(..)` is a Promise-aware Ajax utility,
       // like we defined earlier in the chapter

       var p1 = request( "http://some.url.1/" );
       var p2 = request( "http://some.url.2/" );

       Promise.all( [p1,p2] )
       .then( function(msgs){
           // both `p1` and `p2` fulfill and pass in
           // their messages here
           return request(
               "http://some.url.3/?v=" + msgs.join(",")
           );
       } )
       .then( function(msg){
           console.log( msg );
       } );
     #+END_SRC
**** Promise.race([ .. ])
Not to be confused with a race condition, this works like Promise.all, but only waits for the first one to finish, not all of them.
     #+BEGIN_SRC js
       // `request(..)` is a Promise-aware Ajax utility,
       // like we defined earlier in the chapter

       var p1 = request( "http://some.url.1/" );
       var p2 = request( "http://some.url.2/" );

       Promise.race( [p1,p2] )
       .then( function(msg){
           // either `p1` or `p2` will win the race
           return request(
               "http://some.url.3/?v=" + msg
           );
       } )
       .then( function(msg){
           console.log( msg );
       } );
     #+END_SRC
     #+BEGIN_SRC js
     #+END_SRC
     #+BEGIN_SRC js
     #+END_SRC
     #+BEGIN_SRC js
     #+END_SRC
     #+BEGIN_SRC js
     #+END_SRC
     #+BEGIN_SRC js
     #+END_SRC
     #+BEGIN_SRC js
     #+END_SRC
     #+BEGIN_SRC js
     #+END_SRC
     #+BEGIN_SRC js
     #+END_SRC
     #+BEGIN_SRC js
     #+END_SRC
